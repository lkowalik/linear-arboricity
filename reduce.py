from itertools import combinations
from copy import copy


def print_map_of_lists(ll):
    for ind in ll:
        print(ind, ':', *(ll[ind]))
    print('---------------')


# color_inner: a recursive function which returns True when the outer coloring plus the partial coloring of
# the configuration can be extended to the whole configuration.
# free_colors[v]: list of free colors at v (may contain the same color once or twice).
# paths: dictionary indexed by pairs (color, vertex). paths[(c,v)] == w iff there is a path between v an w of color c=1,2,3,4.
# These are maximal paths formed by edges of the configuration colored with color and by the outer paths generated by generate_outer_paths
# edge_index: the next edge inside the configuration to color, i.e., we assume that all edges from edges[:edge_index] have been colored.
# remove_edge: if True, it means we color the configuration with edge edge_to_remove removed.
def color_inner(free_colors, paths, edge_index, remove_edge=True):
    if edge_index == len(edges):  # everything colored.
        return True

    a, b = edges[edge_index]
    if remove_edge:
        if edge_to_remove == (a, b):  # skip coloring (a,b)
            return color_inner(free_colors, paths, edge_index + 1, remove_edge)

    for color in set(free_colors[a]) & set(free_colors[b]):
        if not ((color, a) in paths and paths[(color, a)] == b):  # ab does not close a cycle
            # remove *one* copy of color from free_colors[a] and free_colors[b]
            free_colors[a].remove(color)
            free_colors[b].remove(color)

            new_paths = copy(paths)

            # extend path(s) stored in paths (if any)
            if (color, a) in paths:  # extend at a
                x = new_paths.pop((color, a))
            else:
                x = a

            if (color, b) in paths:  # extend at b
                y = new_paths.pop((color, b))
            else:
                y = b

            new_paths[(color, x)] = y
            new_paths[(color, y)] = x

            # color the remaining edges
            success = color_inner(free_colors, new_paths, edge_index + 1, remove_edge)

            # uncolor a,b and restore the previous state of free_colors and paths.
            free_colors[a].append(color)
            free_colors[b].append(color)

            if success:
                # we colored all the inner edges, no need to consider other colorings of ab
                return True

    # none of the colors for ab worked, so we return false
    return False


# given colors of outer edges of every vertex computes for each vertex the colors (with multiplicities) that are still free.
def get_free_colors(outer_colors):
    global vertices
    free_colors = {v: [] for v in vertices}
    num_colors = [1, 2, 2, 2, 2]
    for v in vertices:
        for color in [0, 1, 2, 3, 4]:
            for _ in range(num_colors[color] - outer_colors[v].count(color)):
                free_colors[v].append(color)
    return free_colors


# generate_outer_paths:
# recursive function which generates (all possibilities of) all monochromatic paths that go outside between the
# vertices of the configuration when all paths are generated (at the bottom of the recursion), it proceeds as follows:
# 1) call color_inner with remove_edge = True to see if the conf. can be colored to get a coloring of the smaller
# graph.
# 2) If not, we skip the current coloring of the outer part (i.e., coloring of the outer edges and the paths).
# 3) If so, calls color_inner with remove_edge = False, i.e., tries to extend the coloring of the outer part to the
# configuration.
#
# paths_endpoints[c] for c in {1,2,3,4}, is a list of all possible path endpoints of color c,
#                    i.e., it is the list of vertices incident to an outer edge of color c.
# paths represents the paths generated so far. More precisely, paths[(c,x)] for c in {1,2,3,4} and vertex x,
# is the other endpoint of an already created path of color c incident to x.
# we assume that all (possibilities of) paths of colors up to color-1 have been generated.
# also, we assume that all (possibilities of) paths of color color that have an endpoint in paths_endpoints[color][0,..,pos-1] have been generated.
# here, we generate all possibilities of paths of color color that have an endpoint in paths_endpoints[color][pos].
#

def generate_outer_paths(outer_colors, paths_endpoints, paths, color, pos):
    if color > 4:  # all paths are generated (at the bottom of the recursion).
        free_colors = get_free_colors(outer_colors)

        if color_inner(free_colors, paths, 0, remove_edge=True):
            if not color_inner(free_colors, paths, 0, remove_edge=False):
                print("NOT reducible for the following coloring of the outer edges:")
                print_map_of_lists(outer_colors)
                print("Not reducible")
                exit(0)
        return

    if pos == len(paths_endpoints[color]):  # all (possibilities of) paths of colors up to color have been generated.
        generate_outer_paths(outer_colors, paths_endpoints, paths, color + 1, 0)
        return

    x = paths_endpoints[color][pos]
    if (color, x) not in paths:  # x is not an endpoint of a path of color color yet.
        # match x with each of the endpoints of paths_endpoints[color]
        for y in paths_endpoints[color][pos + 1:]:
            if (color, y) not in paths:  # both x and y are not endpoints of a path of color color yet.
                paths[(color, x)] = y
                paths[(color, y)] = x
                generate_outer_paths(outer_colors, paths_endpoints, paths, color, pos + 1)
                paths.pop((color, x))
                paths.pop((color, y))

    # do not match x with anything (i.e., eiter it was matched with an earlier vertex or it is not matched at all).
    generate_outer_paths(outer_colors, paths_endpoints, paths, color, pos + 1)


# generate_outside_colorings:
# recursive function which generates all possible colorings of the outer edges,
# i.e., edges outside the configuration incident to the vertices of the configuration
# when all these colorings are generated, it calls generate_outer_paths.
#
# Assumes that for every i=0,..,v-1 outer_colors[vertices[i]] is the list of already generated outer colors at vertex
# vertices[i].
# Generates all possible outer colors of vertices[v] (possibly with duplicates) and for each of them calls itself
# recursively to consider v+1,v+2,...
def generate_outside_colorings(outer_colors, v):
    global edges
    global vertices
    global degrees
    global inner_degrees
    global num_vertices

    if v >= num_vertices:  # all lists of free colors are generated.
        paths_endpoints = [[] for _ in range(5)]  # paths_endpoints[0] will be always empty.
        for id_v in vertices:
            for color in [1, 2, 3, 4]:
                if outer_colors[id_v].count(color) == 1:
                    paths_endpoints[color].append(id_v)
        generate_outer_paths(outer_colors, paths_endpoints, {}, 1, 0)
        return

    id_v = vertices[v]

    # 0 is the matching color.
    all_colors = [0, 1, 1, 2, 2, 3, 3, 4, 4]

    prev = [-1]
    for subset in combinations(all_colors, degrees[id_v] - inner_degrees[id_v]):
        if list(subset) != prev:
            prev = list(subset)
            outer_colors[id_v] = list(subset)
            generate_outside_colorings(outer_colors, v + 1)


# main script starts here
num_vertices = int(input())

degrees = {}  # degrees[v] = degree of vertex v in the graph
inner_degrees = {}  # inner_degrees[v] = degree of vertex v *inside* the configuration

edges = []  # list of all edges (pairs) in the configuration
vertices = []  # list of vertex ids (strings)

# read the configuration
for i in range(num_vertices):
    l = input().split()
    id_v = l[0]
    vertices.append(id_v)
    degrees[id_v] = int(l[1])
    inner_degrees[id_v] = len(l) - 2
    for n_id in l[2:]:
        if id_v < n_id:
            edges.append((id_v, n_id))

# edge to remove when applying inductive step.
edge_to_remove = tuple(sorted(input().split()[1:3]))

# executes recursive function which generates all possible colorings of the outer edges,
# i.e., edges outside the configuration incident to the vertices of the configuration
# when all these colorings are generated, it calls generate_outer_paths.
generate_outside_colorings({}, 0)

print("REDUCIBLE.")
